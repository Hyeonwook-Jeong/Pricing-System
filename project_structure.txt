# Project Structure
PRICING_SYSTEM/
│
├── main.py                 # Main application entry point
├── requirements.txt        # Project dependencies
├── README.md              # Project documentation
│
├── gui/                   # GUI related modules
│   ├── __init__.py
│   └── tabs/             # Tab implementations
│       ├── __init__.py
│       ├── base_tab.py
│       ├── data_centre_tab.py
│       ├── performance_tab.py
│       ├── claim_tab.py
│       └── correlation_tab.py
│
└── utils/                 # Utility modules
    ├── __init__.py
    ├── data_processor.py
    └── plot_utils.py

# requirements.txt
customtkinter>=5.2.0
matplotlib>=3.7.1
numpy>=1.24.3
pandas>=2.0.2
Pillow>=9.5.0
seaborn>=0.12.2

# main.py
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import customtkinter as ctk
import pandas as pd
import traceback
from pathlib import Path
from datetime import datetime
from PIL import Image, ImageTk

from gui.tabs import (
    DataCentreTab,
    PerformanceTab,
    ClaimTab,
    CorrelationTab
)
from utils.data_processor import DataProcessor

class GeneralPricingSystem(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.data_processor = DataProcessor()
        self.setup_window()
        self.create_gui()

    def setup_window(self):
        """Initialize window settings and theme"""
        self.title("GPS - General Pricing System")
        self.geometry("1200x800")
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

    def create_gui(self):
        """Create the main GUI components"""
        self.create_main_container()
        self.create_header()
        self.create_status_label()
        self.create_notebook()
        self.setup_tabs()

    def create_main_container(self):
        """Create the main container frame"""
        self.main_container = ctk.CTkFrame(self)
        self.main_container.pack(fill="both", expand=True, padx=10, pady=10)

    def create_header(self):
        """Create the header with logo and program name"""
        # Header panel
        self.header_panel = ctk.CTkFrame(self.main_container, height=60, fg_color="white")
        self.header_panel.pack(fill="x", padx=5, pady=(5, 0))
        self.header_panel.pack_propagate(False)

        # Logo frame
        self.logo_frame = ctk.CTkFrame(self.header_panel, height=60, fg_color="white")
        self.logo_frame.pack(fill="x", padx=5, pady=2)
        self.logo_frame.pack_propagate(False)

        # Header content
        self.header_content = ctk.CTkFrame(self.logo_frame, height=50, fg_color="white")
        self.header_content.pack(fill="x", expand=True)

        # Compass label
        self.compass_label = ctk.CTkLabel(
            self.header_content,
            text="Compass",
            font=("Helvetica", 35, "bold"),
            text_color="black"
        )
        self.compass_label.pack(expand=True, pady=10)

        # Allianz logo
        self.load_company_logo()

    def load_company_logo(self):
        """Load and display company logo"""
        try:
            logo_image = Image.open("./utils/_logo_.png")
            ctk_logo = ctk.CTkImage(
                light_image=logo_image,
                dark_image=logo_image,
                size=(220, 40)
            )
            
            self.allianz_logo = ctk.CTkLabel(
                self.header_content,
                image=ctk_logo,
                text=""
            )
            self.allianz_logo.place(relx=1.0, rely=0.5, anchor="e", x=-20, y=0)
        except Exception as e:
            print(f"Error loading logo: {e}")

    def create_status_label(self):
        """Create status message display"""
        self.status_label = ctk.CTkLabel(
            self.main_container,
            text="",
            text_color="yellow"
        )
        self.status_label.pack(fill="x", padx=5)

    def create_notebook(self):
        """Create notebook for tabs"""
        self.notebook = ttk.Notebook(self.main_container)
        self.notebook.pack(fill="both", expand=True, padx=5, pady=5)
        self.notebook.bind('<<NotebookTabChanged>>', self.on_tab_changed)

    def setup_tabs(self):
        """Setup all tabs"""
        self.tabs = {
            'Data Centre': DataCentreTab(self.notebook, self.data_processor),
            'Performance': PerformanceTab(self.notebook, self.data_processor),
            'Claim': ClaimTab(self.notebook, self.data_processor),
            'Correlation': CorrelationTab(self.notebook, self.data_processor)
        }

        for name, tab in self.tabs.items():
            self.notebook.add(tab, text=name)

    def on_tab_changed(self, event):
        """Handle tab change events"""
        try:
            current_tab = self.notebook.select()
            tab_name = self.notebook.tab(current_tab, "text")
            
            if self.data_processor.has_data():
                print(f"Tab changed to: {tab_name}")
                self.tabs[tab_name].update_view()
        except Exception as e:
            self.show_error("Error updating tab visualizations", e)

    def show_error(self, message, error):
        """Display error message"""
        error_msg = f"{message}: {str(error)}"
        self.status_label.configure(text=error_msg)
        messagebox.showerror("Error", error_msg)
        print(f"Error: {error_msg}")
        print(traceback.format_exc())

if __name__ == "__main__":
    try:
        app = GeneralPricingSystem()
        app.mainloop()
    except Exception as e:
        print(f"Application error: {str(e)}")
        print(traceback.format_exc())

# gui/tabs/base_tab.py
import customtkinter as ctk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
from utils.plot_utils import PlotUtils

class BaseTab(ctk.CTkFrame):
    def __init__(self, parent, data_processor):
        super().__init__(parent)
        self.data_processor = data_processor
        self.graphs = {}
        self.setup_ui()

    def setup_ui(self):
        """Setup UI components - to be implemented by child classes"""
        raise NotImplementedError

    def create_graph_frame(self, parent, title, row, column, columnspan=1):
        """Create a frame for matplotlib graph"""
        frame = ctk.CTkFrame(parent)
        frame.grid(row=row, column=column, sticky="nsew", padx=5, pady=5, columnspan=columnspan)

        # Title
        title_label = ctk.CTkLabel(
            frame,
            text=title,
            font=("Helvetica", 16, "bold")
        )
        title_label.pack(pady=5)

        # matplotlib graph
        fig = Figure(figsize=(8, 6), dpi=100)
        PlotUtils.setup_figure(fig)
        
        ax = fig.add_subplot(111)
        PlotUtils.setup_dark_style(ax)
            
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=5, pady=5)

        return {"frame": frame, "fig": fig, "ax": ax, "canvas": canvas}

    def update_view(self):
        """Update all visualizations - to be implemented by child classes"""
        raise NotImplementedError

# gui/tabs/claim_tab.py
from .base_tab import BaseTab
import customtkinter as ctk
import numpy as np
from utils.plot_utils import PlotUtils
import matplotlib.pyplot as plt

class ClaimTab(BaseTab):
    def setup_ui(self):
        """Setup Claim tab UI components"""
        # Scrollable container
        self.scrollable_frame = ctk.CTkScrollableFrame(self)
        self.scrollable_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # Graph container
        self.graphs_container = ctk.CTkFrame(self.scrollable_frame)
        self.graphs_container.pack(fill="both", expand=True, padx=1, pady=1)

        # Create all graph frames
        self.create_graph_frames()
        self.configure_grid()

    def create_graph_frames(self):
        """Create all graph frames for claim visualization"""
        self.graphs = {
            'age': self.create_graph_frame(
                self.graphs_container,
                "Claims by Age Group",
                row=0, column=0
            ),
            'amount': self.create_graph_frame(
                self.graphs_container,
                "Claim Amount Distribution",
                row=0, column=1
            ),
            'diagnosis': self.create_graph_frame(
                self.graphs_container,
                "Claims by Diagnosis",
                row=1, column=0
            ),
            'monthly_trend': self.create_graph_frame(
                self.graphs_container,
                "Monthly Claim Trend",
                row=1, column=1
            ),
            'yearly_trend': self.create_graph_frame(
                self.graphs_container,
                "Yearly Claim Trend",
                row=2, column=0
            ),
            'avg_amount': self.create_graph_frame(
                self.graphs_container,
                "Average Claim by Age",
                row=2, column=1
            ),
            'gender': self.create_graph_frame(
                self.graphs_container,
                "Claims by Gender",
                row=3, column=0
            ),
            'seasonal': self.create_graph_frame(
                self.graphs_container,
                "Seasonal Pattern",
                row=3, column=1
            )
        }

    def configure_grid(self):
        """Configure grid layout"""
        for i in range(4):
            self.graphs_container.grid_columnconfigure(i, weight=1)
            self.graphs_container.grid_rowconfigure(i, weight=1)

    def update_view(self):
        """Update all claim visualizations"""
        if not self.data_processor.has_data():
            return

        try:
            self.update_age_distribution()
            self.update_amount_distribution()
            self.update_diagnosis_distribution()
            self.update_monthly_trend()
            self.update_yearly_trend()
            self.update_average_amount()
            self.update_gender_distribution()
            self.update_seasonal_pattern()
        except Exception as e:
            print(f"Error updating visualizations: {str(e)}")
            raise e

    def update_age_distribution(self):
        """Update age distribution graph"""
        ax = self.graphs['age']['ax']
        ax.clear()
        
        age_dist = self.data_processor.get_age_distribution()
        if age_dist is not None:
            ax.bar(range(len(age_dist)), age_dist.values, color='skyblue')
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Number of Claims')
            ax.set_xticks(range(len(age_dist)))
            ax.set_xticklabels(age_dist.index, rotation=45)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['age']['canvas'].draw()

    def update_amount_distribution(self):
        """Update amount distribution graph"""
        ax = self.graphs['amount']['ax']
        ax.clear()
        
        amount_data = self.data_processor.get_amount_distribution()
        if amount_data is not None:
            ax.hist(amount_data, bins=50, color='lightgreen')
            ax.set_xlabel('Claim Amount')
            ax.set_ylabel('Frequency')
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['amount']['canvas'].draw()

    def update_diagnosis_distribution(self):
        """Update diagnosis distribution graph"""
        ax = self.graphs['diagnosis']['ax']
        ax.clear()
        
        diagnosis_data = self.data_processor.get_diagnosis_distribution()
        if diagnosis_data is not None:
            ax.barh(range(len(diagnosis_data)), diagnosis_data.values, color='salmon')
            ax.set_xlabel('Number of Claims')
            ax.set_ylabel('Diagnosis')
            ax.set_yticks(range(len(diagnosis_data)))
            ax.set_yticklabels(diagnosis_data.index)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['diagnosis']['canvas'].draw()

    def update_monthly_trend(self):
        """Update monthly trend graph"""
        ax = self.graphs['monthly_trend']['ax']
        ax.clear()
        
        monthly_data = self.data_processor.get_monthly_trend()
        if monthly_data is not None:
            ax.plot(range(len(monthly_data)), monthly_data.values, marker='o')
            ax.set_xlabel('Month')
            ax.set_ylabel('Number of Claims')
            ax.set_xticks(range(len(monthly_data)))
            ax.set_xticklabels([str(p) for p in monthly_data.index], rotation=45)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['monthly_trend']['canvas'].draw()

    def update_yearly_trend(self):
        """Update yearly trend graph"""
        ax = self.graphs['yearly_trend']['ax']
        ax.clear()
        
        yearly_data = self.data_processor.get_yearly_trend()
        if yearly_data is not None:
            ax1 = ax
            ax2 = ax1.twinx()
            
            x = range(len(yearly_data.index))
            bars = ax1.bar(x, yearly_data[('amount', 'count')],
                         color='lightblue', alpha=0.7)
            line = ax2.plot(x, yearly_data[('amount', 'mean')],
                          color='lightgreen', marker='o', linewidth=2)
            
            ax1.set_xlabel('Year')
            ax1.set_ylabel('Number of Claims', color='lightblue')
            ax2.set_ylabel('Average Claim Amount', color='lightgreen')
            
            ax1.set_xticks(x)
            ax1.set_xticklabels(yearly_data.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax1.text(bar.get_x() + bar.get_width()/2., height,
                        f'{int(height):,}',
                        ha='center', va='bottom', color='white')
                
        PlotUtils.setup_dark_style(ax)
        PlotUtils.setup_dark_style(ax2)
        self.graphs['yearly_trend']['canvas'].draw()

    def update_average_amount(self):
        """Update average amount by age graph"""
        ax = self.graphs['avg_amount']['ax']
        ax.clear()
        
        avg_by_age = self.data_processor.get_average_amount_by_age()
        if avg_by_age is not None:
            x = range(len(avg_by_age))
            bars = ax.bar(x, avg_by_age.values, color='lightblue')
            
            ax.set_xticks(x)
            ax.set_xticklabels(avg_by_age.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'${height:,.0f}',
                       ha='center', va='bottom', color='white')
                
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Average Claim Amount ($)')
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['avg_amount']['canvas'].draw()

    def update_gender_distribution(self):
        """Update gender distribution graph"""
        ax = self.graphs['gender']['ax']
        ax.clear()
        
        gender_data = self.data_processor.get_gender_distribution()
        if gender_data is not None:
            # Group data by age_group
            age_groups = gender_data['age_group'].unique()
            n_groups = len(age_groups)
            
            bar_width = 0.35
            index = np.arange(n_groups)
            
            # Get data for males and females
            male_data = gender_data[gender_data['gender'] == 'M']['count'].values
            female_data = gender_data[gender_data['gender'] == 'F']['count'].values
            
            # Create bars
            ax.bar(index - bar_width/2, male_data, bar_width, 
                  label='Male', color='lightblue')
            ax.bar(index + bar_width/2, female_data, bar_width,
                  label='Female', color='lightpink')
            
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Number of Claims')
            ax.set_xticks(index)
            ax.set_xticklabels(age_groups, rotation=45)
            ax.legend()
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['gender']['canvas'].draw()

    def update_seasonal_pattern(self):
        """Update seasonal pattern graph"""
        ax = self.graphs['seasonal']['ax']
        ax.clear()
        
        seasonal_data = self.data_processor.get_seasonal_pattern()
        if seasonal_data is not None:
            ax1 = ax
            ax2 = ax1.twinx()
            
            x = range(len(seasonal_data.index))
            bars = ax1.bar(x, seasonal_data[('amount', 'count')],
                         color='lightblue', alpha=0.7)
            line = ax2.plot(x, seasonal_data[('amount', 'mean')],
                          color='lightgreen', marker='o', linewidth=2)
            
            ax1.set_xlabel('Season')
            ax1.set_ylabel('Number of Claims', color='lightblue')
            ax2.set_ylabel('Average Claim Amount', color='lightgreen')
            
            ax1.set_xticks(x)
            ax1.set_xticklabels(seasonal_data.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax1.text(bar.get_x() + bar.get_width()/2., height,
                        f'{int(height):,}',
                        ha='center', va='bottom', color='white')
                
        PlotUtils.setup_dark_style(ax)
        PlotUtils.setup_dark_style(ax2)
        self.graphs['seasonal']['canvas'].draw()

# gui/tabs/correlation_tab.py
from .base_tab import BaseTab
import customtkinter as ctk
import numpy as np
import seaborn as sns
from utils.plot_utils import PlotUtils
import matplotlib.pyplot as plt
import pandas as pd  # 이 줄을 추가하세요

class CorrelationTab(BaseTab):
    def setup_ui(self):
        """Setup Correlation tab UI components"""
        # Create scrollable frame
        self.scrollable_frame = ctk.CTkScrollableFrame(self)
        self.scrollable_frame.pack(fill="both", expand=True, padx=5, pady=5)

        # Correlation visualization frames
        self.correlation_frames = ctk.CTkFrame(self.scrollable_frame)
        self.correlation_frames.pack(fill="both", expand=True, padx=5, pady=5)

        # Create graph frames
        self.create_graph_frames()
        self.configure_grid()

    def create_graph_frames(self):
        """Create all graph frames for correlation analysis"""
        self.graphs = {
            'heatmap': self.create_graph_frame(
                self.correlation_frames,
                "Correlation Heatmap",
                row=0, column=0, columnspan=2
            ),
            'pairs': self.create_graph_frame(
                self.correlation_frames,
                "Pairwise Relationships",
                row=1, column=0, columnspan=2
            ),
            'top_correlations': self.create_graph_frame(
                self.correlation_frames,
                "Top 10 Correlations",
                row=2, column=0
            ),
            'scatter': self.create_graph_frame(
                self.correlation_frames,
                "Key Variables vs Claims",
                row=2, column=1
            )
        }

    def configure_grid(self):
        """Configure grid layout"""
        self.correlation_frames.grid_columnconfigure(0, weight=1)
        self.correlation_frames.grid_columnconfigure(1, weight=1)
        for i in range(3):
            self.correlation_frames.grid_rowconfigure(i, weight=1)

    def update_view(self):
        """Update all correlation visualizations"""
        if not self.data_processor.has_data():
            return

        self.update_correlation_heatmap()
        self.update_pairwise_relationships()
        self.update_top_correlations()
        self.update_key_variables_scatter()

    def update_correlation_heatmap(self):
        """Update correlation heatmap"""
        ax = self.graphs['heatmap']['ax']
        ax.clear()
        fig = self.graphs['heatmap']['fig']
        
        corr_matrix = self.data_processor.get_correlation_matrix()
        if corr_matrix is not None:
            fig.subplots_adjust(left=0.15, right=0.95, bottom=0.2, top=0.9)
            
            sns.heatmap(corr_matrix, 
                       annot=True, 
                       cmap='coolwarm', 
                       ax=ax,
                       fmt='.2f',
                       annot_kws={'size': 8},
                       mask=np.triu(np.ones_like(corr_matrix, dtype=bool)))
            
            ax.set_title('Correlation Heatmap', color='white', pad=20)
            plt.setp(ax.get_xticklabels(), rotation=45, ha='right')
            plt.setp(ax.get_yticklabels(), rotation=0)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['heatmap']['canvas'].draw()

    def update_pairwise_relationships(self):
        """Update pairwise relationships visualization"""
        ax = self.graphs['pairs']['ax']
        ax.clear()
        fig = self.graphs['pairs']['fig']
        
        if self.data_processor.has_data():
            fig.subplots_adjust(left=0.1, right=0.95, bottom=0.2, top=0.9)
            
            # Use correlation matrix to get top categorical features
            corr_matrix = self.data_processor.get_correlation_matrix()
            
            # Get top features based on their correlation to each other
            correlation_values = corr_matrix.abs().sum()
            top_features = correlation_values.sort_values(ascending=False)[:4].index
            
            data = self.data_processor.get_data()
            n_features = len(top_features)
            
            for i in range(n_features):
                for j in range(n_features):
                    plt_ax = ax.inset_axes([0.25*i, 0.25*j, 0.23, 0.23])
                    
                    # If not on diagonal, create scatter/bar plot
                    if i != j:
                        # For categorical variables, create stacked bar plot
                        crosstab = pd.crosstab(data[top_features[i]], data[top_features[j]])
                        crosstab.plot(kind='bar', stacked=True, ax=plt_ax, legend=False)
                        plt_ax.set_xlabel('')
                        plt_ax.set_ylabel('')
                    else:
                        # On diagonal, show distribution
                        data[top_features[i]].value_counts().plot(kind='bar', ax=plt_ax)
                        plt_ax.set_title('')

                    if i == 0:
                        plt_ax.set_ylabel(top_features[j], color='white')
                    if j == n_features-1:
                        plt_ax.set_xlabel(top_features[i], color='white')
                    plt_ax.tick_params(colors='white', labelsize=8, rotation=45)
            
            ax.set_title('Pairwise Relationships of Top Categorical Features', color='white', pad=20)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['pairs']['canvas'].draw()

    def update_top_correlations(self):
        """Update top correlations visualization"""
        ax = self.graphs['top_correlations']['ax']
        ax.clear()
        fig = self.graphs['top_correlations']['fig']
        
        if self.data_processor.has_data():
            fig.subplots_adjust(left=0.3, right=0.95, bottom=0.2, top=0.9)
            
            corr_matrix = self.data_processor.get_correlation_matrix()
            
            # Calculate overall correlation and sort
            correlation_values = corr_matrix.abs().sum()
            top_corr = correlation_values.sort_values(ascending=True)
            top_corr = top_corr.drop(top_corr.index[top_corr.index == top_corr.index[0]])
            
            colors = ['red' if x < 0 else 'green' for x in top_corr]
            bars = ax.barh(range(len(top_corr)), top_corr, color=colors)
            ax.set_yticks(range(len(top_corr)))
            ax.set_yticklabels(top_corr.index, fontsize=8)
            ax.set_xlabel('Correlation Coefficient')
            ax.set_title('Correlations between Categorical Variables', pad=20)
            
            for i, bar in enumerate(bars):
                width = bar.get_width()
                ax.text(width, i, f'{width:.2f}', 
                    color='white', 
                    va='center',
                    ha='left' if width >= 0 else 'right')
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['top_correlations']['canvas'].draw()

    def update_key_variables_scatter(self):
        """Update key variables scatter plots"""
        ax = self.graphs['scatter']['ax']
        ax.clear()
        fig = self.graphs['scatter']['fig']
        
        if self.data_processor.has_data():
            fig.subplots_adjust(left=0.15, right=0.95, bottom=0.2, top=0.9)
            
            corr_matrix = self.data_processor.get_correlation_matrix()
            
            # Get top features based on overall correlation
            correlation_values = corr_matrix.abs().sum()
            top_vars = correlation_values.sort_values(ascending=False)[1:4].index
            
            # For categorical variables, use stacked bar plot
            data = self.data_processor.get_data()
            
            colors = plt.cm.tab10(np.linspace(0, 1, len(top_vars)))
            for var, color in zip(top_vars, colors):
                # Create a cross-tabulation for the variables
                crosstab = pd.crosstab(data[var], columns='count', normalize='index')
                crosstab.plot(kind='bar', color=color, ax=ax, label=var)
            
            ax.set_xlabel('Categories')
            ax.set_ylabel('Proportion')
            ax.legend()
            ax.set_title('Distribution of Top Categorical Variables', pad=20)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['scatter']['canvas'].draw()

# gui/tabs/data_centre_tab.py
from gui.tabs.base_tab import BaseTab
import customtkinter as ctk
import tkinter as tk
from tkinter import filedialog, messagebox
from datetime import datetime
from pathlib import Path
import shutil

class DataCentreTab(BaseTab):
    def setup_ui(self):
        """Setup Data Centre tab UI components"""
        # Create main scrollable frame
        self.main_scrollable = ctk.CTkScrollableFrame(self)
        self.main_scrollable.pack(fill="both", expand=True)
        
        # Main container frame with fixed size for data selection
        self.main_container = ctk.CTkFrame(self.main_scrollable)
        self.main_container.pack(fill="x", padx=20, pady=(20,5))
        
        # Initialize selection tracking variables
        self.selected_database = None  # 'plsql' or 'local'
        self.selected_dataset = None
        
        # Create UI components
        self.create_data_selection_frame()
        self.create_data_filtering_frame()

    def create_section_label(self, parent, text):
        """Create section label"""
        label = ctk.CTkLabel(
            parent,
            text=text,
            font=("Helvetica", 16, "bold")
        )
        label.pack(anchor="w", padx=10, pady=5)

    def create_data_selection_frame(self):
        """Create data selection section"""
        # Main Label
        self.create_section_label(self.main_container, "Data Selection")
        
        # Create PLSQL Database Section
        self.create_plsql_database_section()
        
        # Create Local Database Section
        self.create_local_database_section()
        
        # Create Confirm Button
        self.create_confirm_button()

    def create_plsql_database_section(self):
        """Create PLSQL database section"""
        # PLSQL Database Frame
        self.plsql_frame = ctk.CTkFrame(self.main_container)
        self.plsql_frame.pack(fill="x", padx=10, pady=5)
        
        # Database Label
        self.create_section_label(self.plsql_frame, "PLSQL Database")
        
        # PLSQL Database Listbox
        self.plsql_listbox_frame = ctk.CTkFrame(self.plsql_frame)
        self.plsql_listbox_frame.pack(fill="x", padx=10, pady=5)
        
        self.plsql_listbox = tk.Listbox(
            self.plsql_listbox_frame,
            bg='#2B2B2B',
            fg='white',
            selectmode=tk.SINGLE,
            height=8
        )
        self.plsql_listbox.pack(side="left", fill="x", expand=True)
        self.plsql_listbox.bind('<<ListboxSelect>>', self.on_plsql_select)
        
        self.plsql_scrollbar = tk.Scrollbar(self.plsql_listbox_frame, orient="vertical")
        self.plsql_scrollbar.pack(side="right", fill="y")
        
        self.plsql_listbox.config(yscrollcommand=self.plsql_scrollbar.set)
        self.plsql_scrollbar.config(command=self.plsql_listbox.yview)

        # PLSQL Update Section
        self.plsql_update_frame = ctk.CTkFrame(self.plsql_frame)
        self.plsql_update_frame.pack(fill="x", padx=10, pady=5)
        
        self.plsql_entry = ctk.CTkEntry(
            self.plsql_update_frame,
            placeholder_text="Name of Dataset"
        )
        self.plsql_entry.pack(side="left", fill="x", expand=True, padx=(0,10))
        
        self.plsql_update_button = ctk.CTkButton(
            self.plsql_update_frame,
            text="Update",
            width=100,
            command=self.update_plsql_database
        )
        self.plsql_update_button.pack(side="right")

    def create_local_database_section(self):
        """Create local database section"""
        # Local Database Frame
        self.local_frame = ctk.CTkFrame(self.main_container)
        self.local_frame.pack(fill="x", padx=10, pady=5)
        
        # Local Database Label
        self.create_section_label(self.local_frame, "Local Database")
        
        # Local Database Listbox
        self.local_listbox_frame = ctk.CTkFrame(self.local_frame)
        self.local_listbox_frame.pack(fill="x", padx=10, pady=5)
        
        self.local_listbox = tk.Listbox(
            self.local_listbox_frame,
            bg='#2B2B2B',
            fg='white',
            selectmode=tk.SINGLE,
            height=8
        )
        self.local_listbox.pack(side="left", fill="x", expand=True)
        self.local_listbox.bind('<<ListboxSelect>>', self.on_local_select)
        
        self.local_scrollbar = tk.Scrollbar(self.local_listbox_frame, orient="vertical")
        self.local_scrollbar.pack(side="right", fill="y")
        
        self.local_listbox.config(yscrollcommand=self.local_scrollbar.set)
        self.local_scrollbar.config(command=self.local_listbox.yview)
        
        # File Upload Frame
        self.upload_frame = ctk.CTkFrame(self.local_frame)
        self.upload_frame.pack(fill="x", padx=10, pady=5)
        
        self.file_label = ctk.CTkLabel(
            self.upload_frame,
            text="Please select a file"
        )
        self.file_label.pack(side="left", padx=5, fill="x", expand=True)
        
        self.file_upload_button = ctk.CTkButton(
            self.upload_frame,
            text="Upload Data File",
            command=self.upload_file,
            width=150
        )
        self.file_upload_button.pack(side="right", padx=5)

    def create_confirm_button(self):
        """Create confirm button"""
        self.confirm_frame = ctk.CTkFrame(self.main_container)
        self.confirm_frame.pack(fill="x", padx=10, pady=10)
        
        self.confirm_button = ctk.CTkButton(
            self.confirm_frame,
            text="Confirm",
            width=150,
            command=self.confirm_selection,
            state="disabled"  # Initially disabled
        )
        self.confirm_button.pack(side="right", padx=5)

        # Status label for showing messages
        self.status_label = ctk.CTkLabel(
            self.confirm_frame,
            text="",
            text_color="yellow"
        )
        self.status_label.pack(side="left", padx=5, fill="x", expand=True)

    def create_data_filtering_frame(self):
        """Create data filtering section"""
        # Create filtering frame
        self.filtering_container = ctk.CTkFrame(self.main_scrollable)
        self.filtering_container.pack(fill="x", padx=20, pady=5)
        
        # Filtering Section Label
        self.create_section_label(self.filtering_container, "Data Filtering")
        
        # Create filter options frame
        self.filter_options = ctk.CTkFrame(self.filtering_container)
        self.filter_options.pack(fill="x", padx=10, pady=5)
        
        # Configure grid for filter options
        self.filter_options.grid_columnconfigure(0, weight=1)
        self.filter_options.grid_columnconfigure(1, weight=1)
        
        # Create all filter sections in a 2-column grid
        filters = [
            ("Grouping", "Select your grouping", 
             ["Singapore Individual", "Singapore Corporate", 
              "Dubai Individual", "Summit", "EHP"]),
            ("Country", "Select countries",
             ["United States", "China", "Japan", "Germany", 
              "India", "United Kingdom", "France", "Italy", 
              "Canada", "Brazil", "Russia", "South Korea", 
              "Australia", "Spain", "Mexico", "Indonesia", 
              "Netherlands", "Saudi Arabia", "Switzerland", "Turkey"]),
            ("Continent", "Select continents",
             ["Asia", "Europe", "North America", "South America", 
              "Africa", "Oceania", "Antarctica"]),
            ("Rating Year", "Select rating years",
             [str(year) for year in range(2015, 2025)]),
            ("Start Year", "Select start years",
             [str(year) for year in range(2015, 2025)])
        ]
        
        for i, (label, placeholder, options) in enumerate(filters):
            row = i // 2
            col = i % 2
            self.create_dropdown_filter(label, placeholder, options, row, col)
        
        # Create filter buttons
        self.create_filter_buttons()

    def create_dropdown_filter(self, label_text, placeholder_text, options, row, col):
        """Create a dropdown filter with multi-select capability"""
        # Create frame for this filter
        filter_frame = ctk.CTkFrame(self.filter_options)
        filter_frame.grid(row=row, column=col, padx=5, pady=5, sticky="ew")
        
        # Configure columns
        filter_frame.grid_columnconfigure(1, weight=1)  # Button column
        
        # Create label
        label = ctk.CTkLabel(
            filter_frame,
            text=f"{label_text}:",
            anchor="w"
        )
        label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        
        # Create dropdown button that will trigger the selection window
        dropdown_btn = ctk.CTkButton(
            filter_frame,
            text=placeholder_text,
            width=200,
            command=lambda: self.show_selection_window(label_text, options)
        )
        dropdown_btn.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        
        # Store the button reference
        setattr(self, f"{label_text.lower().replace(' ', '_')}_btn", dropdown_btn)
        
        # Store selected values
        setattr(self, f"{label_text.lower().replace(' ', '_')}_selected", set())

    def create_filter_buttons(self):
        """Create filter action buttons"""
        # Calculate the row for buttons (after all filters)
        button_row = (len(['Grouping', 'Country', 'Continent', 'Rating Year', 'Start Year']) + 1) // 2
        
        # Apply button
        self.apply_filter_btn = ctk.CTkButton(
            self.filter_options,
            text="Apply Filters",
            command=self.apply_filters,
            width=200
        )
        self.apply_filter_btn.grid(row=button_row, column=0, padx=5, pady=10, sticky="e")
        
        # Reset button
        self.reset_filter_btn = ctk.CTkButton(
            self.filter_options,
            text="Reset Filters",
            command=self.reset_filters,
            width=200
        )
        self.reset_filter_btn.grid(row=button_row, column=1, padx=5, pady=10, sticky="w")

    def show_selection_window(self, title, options):
        """Show a popup window with checkboxes for multiple selection"""
        # Create popup window
        popup = ctk.CTkToplevel(self)
        popup.title(f"Select {title}")
        popup.geometry("600x600")
        
        # Get current selections
        current_selections = getattr(self, f"{title.lower().replace(' ', '_')}_selected")
        
        # Create scrollable frame for options
        scroll_frame = ctk.CTkScrollableFrame(popup)
        scroll_frame.pack(fill="both", expand=True, padx=20, pady=(20, 0))
        
        # Dictionary to store checkboxes variables
        checkbox_vars = {}
        
        # Create checkbox for each option
        for option in options:
            var = tk.BooleanVar(value=option in current_selections)
            checkbox_vars[option] = var
            
            checkbox = ctk.CTkCheckBox(
                scroll_frame,
                text=option,
                variable=var,
                width=200
            )
            checkbox.pack(anchor="w", padx=10, pady=2)
        
        # Create buttons frame
        button_frame = ctk.CTkFrame(popup, height=60)
        button_frame.pack(fill="x", padx=20, pady=20, side="bottom")
        button_frame.pack_propagate(False)
        
        # Function to handle selection confirmation
        def confirm_selection():
            selected = {opt for opt, var in checkbox_vars.items() if var.get()}
            attribute_name = f"{title.lower().replace(' ', '_')}_selected"
            setattr(self, attribute_name, selected)
            
            btn = getattr(self, f"{title.lower().replace(' ', '_')}_btn")
            if selected:
                text = f"{len(selected)} item{'s' if len(selected) > 1 else ''} selected"
            else:
                text = f"Select your {title.lower()}"
            btn.configure(text=text)
            
            popup.destroy()
        
        # Function to handle selection cancellation
        def cancel_selection():
            popup.destroy()
        
        # Function to select all options
        def select_all():
            for var in checkbox_vars.values():
                var.set(True)
        
        # Function to clear all selections
        def clear_all():
            for var in checkbox_vars.values():
                var.set(False)
        
        # Create control buttons
        ctk.CTkButton(
            button_frame,
            text="Select All",
            command=select_all,
            width=120,
            height=35
        ).pack(side="left", padx=5, pady=10)
        
        ctk.CTkButton(
            button_frame,
            text="Clear All",
            command=clear_all,
            width=120,
            height=35
        ).pack(side="left", padx=5, pady=10)
        
        ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=cancel_selection,
            width=120,
            height=35
        ).pack(side="right", padx=5, pady=10)
        
        ctk.CTkButton(
            button_frame,
            text="Confirm",
            command=confirm_selection,
            width=120,
            height=35,
            fg_color="#2B6AD0",
            hover_color="#1E4C9A"
        ).pack(side="right", padx=5, pady=10)

    def on_plsql_select(self, event):
        """Handle PLSQL database selection"""
        selection = self.plsql_listbox.curselection()
        if selection:
            self.selected_database = 'plsql'
            self.selected_dataset = self.plsql_listbox.get(selection[0])
            self.local_listbox.selection_clear(0, tk.END)
            self.confirm_button.configure(state="normal")

    def on_local_select(self, event):
        """Handle local database selection"""
        selection = self.local_listbox.curselection()
        if selection:
            self.selected_database = 'local'
            self.selected_dataset = self.local_listbox.get(selection[0])
            self.plsql_listbox.selection_clear(0, tk.END)
            self.confirm_button.configure(state="normal")

    def update_plsql_database(self):
        """Handle PLSQL database update"""
        try:
            dataset_name = self.plsql_entry.get()
            if dataset_name:
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
                self.plsql_listbox.insert(tk.END, f"{dataset_name} - Uploaded at {current_time}")
                self.plsql_entry.delete(0, tk.END)
                self.show_status(f"PLSQL database updated with dataset: {dataset_name}")
            else:
                self.show_status("Please enter a dataset name")
        except Exception as e:
            self.show_error("Error updating PLSQL database", e)

    def upload_file(self):
        """Handle file upload"""
        try:
            file_path = filedialog.askopenfilename(
                title="Select Data File",
                filetypes=[
                    ("CSV files", "*.csv"),
                    ("Excel files", "*.xlsx"),
                    ("Excel files (old)", "*.xls"),
                    ("All files", "*.*")
                ]
            )
            
            if not file_path:
                return

            file_path = Path(file_path)
            self.file_label.configure(text=str(file_path))
            
            if file_path.suffix.lower() not in ['.csv', '.xlsx', '.xls']:
                raise ValueError("Unsupported file format")

            current_time = datetime.now().strftime("%Y-%m-%d %H:%M")
            file_name = file_path.name
            self.local_listbox.insert(tk.END, f"{file_name} - Uploaded at {current_time}")
            
            # Copy file to current working directory
            target_path = Path.cwd() / file_name
            shutil.copy2(file_path, target_path)
            
            self.show_status(f"File uploaded: {file_name}")
            
        except Exception as e:
            self.show_error("Error uploading file", e)

    def confirm_selection(self):
        """Handle confirm button click"""
        if self.selected_database and self.selected_dataset:
            try:
                dataset_name = self.selected_dataset.split(" - ")[0]
                success, error = self.data_processor.load_file(dataset_name)
                
                if success:
                    self.show_status(f"Successfully loaded dataset: {dataset_name}")
                else:
                    raise Exception(error)
                    
            except Exception as e:
                self.show_error("Error loading dataset", e)
        else:
            self.show_status("Please select a dataset first")

    def apply_filters(self):
        """Apply selected filters to the data"""
        try:
            if not self.data_processor.has_data():
                raise ValueError("No data loaded")
            
            # Get selected items from each filter
            selected_groups = list(self.grouping_selected)
            selected_countries = list(self.country_selected)
            selected_continents = list(self.continent_selected)
            selected_rating_years = list(self.rating_year_selected)
            selected_start_years = list(self.start_year_selected)
            
            # Apply filters
            success, error = self.data_processor.apply_filters(
                groups=selected_groups,
                countries=selected_countries,
                continents=selected_continents,
                rating_years=selected_rating_years,
                start_years=selected_start_years
            )
            
            if success:
                filter_summary = self.data_processor.get_filter_summary()
                self.show_status(f"Filters applied successfully\n{filter_summary}")
            else:
                raise Exception(error)
            
        except Exception as e:
            self.show_error("Error applying filters", e)

    def reset_filters(self):
        """Reset all filters to default values"""
        try:
            # Clear all selections
            filter_types = ['grouping', 'country', 'continent', 'rating_year', 'start_year']
            for filter_type in filter_types:
                setattr(self, f"{filter_type}_selected", set())
                btn = getattr(self, f"{filter_type}_btn")
                btn.configure(text=f"Select your {filter_type}")
            
            # Reset data processor filters
            if self.data_processor.has_data():
                success, error = self.data_processor.reset_filters()
                if success:
                    self.show_status("Filters reset successfully")
                else:
                    raise Exception(error)
                
        except Exception as e:
            self.show_error("Error resetting filters", e)

    def show_error(self, message, error):
        """Display error message"""
        error_msg = f"{message}: {str(error)}"
        self.show_status(error_msg)
        messagebox.showerror("Error", error_msg)

    def show_status(self, message):
        """Display status message"""
        if hasattr(self, 'status_label'):
            self.status_label.configure(text=message)

    def update_view(self):
        """Update view (placeholder for base class compatibility)"""
        pass

# gui/tabs/performance_tab.py
from .base_tab import BaseTab
import customtkinter as ctk
import numpy as np
from utils.plot_utils import PlotUtils
import matplotlib.pyplot as plt

class PerformanceTab(BaseTab):
    def setup_ui(self):
        """Setup Performance tab UI components"""
        # Scrollable container
        self.scrollable_frame = ctk.CTkScrollableFrame(self)
        self.scrollable_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # Graph container
        self.graphs_container = ctk.CTkFrame(self.scrollable_frame)
        self.graphs_container.pack(fill="both", expand=True, padx=1, pady=1)

        # Create all graph frames
        self.create_graph_frames()
        self.configure_grid()

    def create_graph_frames(self):
        """Create all graph frames for performance visualization"""
        self.graphs = {
            'age': self.create_graph_frame(
                self.graphs_container,
                "Performance by Age Group",
                row=0, column=0
            ),
            'amount': self.create_graph_frame(
                self.graphs_container,
                "Performance Amount Distribution",
                row=0, column=1
            ),
            'diagnosis': self.create_graph_frame(
                self.graphs_container,
                "Performance by Category",
                row=1, column=0
            ),
            'monthly_trend': self.create_graph_frame(
                self.graphs_container,
                "Monthly Performance Trend",
                row=1, column=1
            ),
            'yearly_trend': self.create_graph_frame(
                self.graphs_container,
                "Yearly Performance Trend",
                row=2, column=0
            ),
            'avg_amount': self.create_graph_frame(
                self.graphs_container,
                "Average Performance by Age",
                row=2, column=1
            ),
            'gender': self.create_graph_frame(
                self.graphs_container,
                "Performance by Gender",
                row=3, column=0
            ),
            'seasonal': self.create_graph_frame(
                self.graphs_container,
                "Seasonal Performance Pattern",
                row=3, column=1
            )
        }

    def configure_grid(self):
        """Configure grid layout"""
        for i in range(4):
            self.graphs_container.grid_columnconfigure(i, weight=1)
            self.graphs_container.grid_rowconfigure(i, weight=1)

    def update_view(self):
        """Update all performance visualizations"""
        if not self.data_processor.has_data():
            return

        try:
            self.update_age_distribution()
            self.update_amount_distribution()
            self.update_diagnosis_distribution()
            self.update_monthly_trend()
            self.update_yearly_trend()
            self.update_average_amount()
            self.update_gender_distribution()
            self.update_seasonal_pattern()
        except Exception as e:
            print(f"Error updating visualizations: {str(e)}")
            raise e

    def update_age_distribution(self):
        """Update age distribution graph"""
        ax = self.graphs['age']['ax']
        ax.clear()
        
        age_dist = self.data_processor.get_age_distribution()
        if age_dist is not None:
            ax.bar(range(len(age_dist)), age_dist.values, color='skyblue')
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Performance Count')
            ax.set_xticks(range(len(age_dist)))
            ax.set_xticklabels(age_dist.index, rotation=45)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['age']['canvas'].draw()

    def update_amount_distribution(self):
        """Update amount distribution graph"""
        ax = self.graphs['amount']['ax']
        ax.clear()
        
        amount_data = self.data_processor.get_amount_distribution()
        if amount_data is not None:
            ax.hist(amount_data, bins=50, color='lightgreen')
            ax.set_xlabel('Performance Amount')
            ax.set_ylabel('Frequency')
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['amount']['canvas'].draw()

    def update_diagnosis_distribution(self):
        """Update diagnosis distribution graph"""
        ax = self.graphs['diagnosis']['ax']
        ax.clear()
        
        diagnosis_data = self.data_processor.get_diagnosis_distribution()
        if diagnosis_data is not None:
            ax.barh(range(len(diagnosis_data)), diagnosis_data.values, color='salmon')
            ax.set_xlabel('Performance Count')
            ax.set_ylabel('Category')
            ax.set_yticks(range(len(diagnosis_data)))
            ax.set_yticklabels(diagnosis_data.index)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['diagnosis']['canvas'].draw()

    def update_monthly_trend(self):
        """Update monthly trend graph"""
        ax = self.graphs['monthly_trend']['ax']
        ax.clear()
        
        monthly_data = self.data_processor.get_monthly_trend()
        if monthly_data is not None:
            ax.plot(range(len(monthly_data)), monthly_data.values, marker='o')
            ax.set_xlabel('Month')
            ax.set_ylabel('Performance Count')
            ax.set_xticks(range(len(monthly_data)))
            ax.set_xticklabels([str(p) for p in monthly_data.index], rotation=45)
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['monthly_trend']['canvas'].draw()

    def update_yearly_trend(self):
        """Update yearly trend graph"""
        ax = self.graphs['yearly_trend']['ax']
        ax.clear()
        
        yearly_data = self.data_processor.get_yearly_trend()
        if yearly_data is not None:
            ax1 = ax
            ax2 = ax1.twinx()
            
            x = range(len(yearly_data.index))
            bars = ax1.bar(x, yearly_data[('amount', 'count')],
                         color='lightblue', alpha=0.7)
            line = ax2.plot(x, yearly_data[('amount', 'mean')],
                          color='lightgreen', marker='o', linewidth=2)
            
            ax1.set_xlabel('Year')
            ax1.set_ylabel('Number of Cases', color='lightblue')
            ax2.set_ylabel('Average Performance Amount', color='lightgreen')
            
            ax1.set_xticks(x)
            ax1.set_xticklabels(yearly_data.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax1.text(bar.get_x() + bar.get_width()/2., height,
                        f'{int(height):,}',
                        ha='center', va='bottom', color='white')
                
        PlotUtils.setup_dark_style(ax)
        PlotUtils.setup_dark_style(ax2)
        self.graphs['yearly_trend']['canvas'].draw()

    def update_average_amount(self):
        """Update average amount by age graph"""
        ax = self.graphs['avg_amount']['ax']
        ax.clear()
        
        avg_by_age = self.data_processor.get_average_amount_by_age()
        if avg_by_age is not None:
            x = range(len(avg_by_age))
            bars = ax.bar(x, avg_by_age.values, color='lightblue')
            
            ax.set_xticks(x)
            ax.set_xticklabels(avg_by_age.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'${height:,.0f}',
                       ha='center', va='bottom', color='white')
                
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Average Performance Amount ($)')
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['avg_amount']['canvas'].draw()

    def update_gender_distribution(self):
        """Update gender distribution graph"""
        ax = self.graphs['gender']['ax']
        ax.clear()
        
        gender_data = self.data_processor.get_gender_distribution()
        if gender_data is not None:
            # Group data by age_group
            age_groups = gender_data['age_group'].unique()
            n_groups = len(age_groups)
            
            bar_width = 0.35
            index = np.arange(n_groups)
            
            # Get data for males and females
            male_data = gender_data[gender_data['gender'] == 'M']['count'].values
            female_data = gender_data[gender_data['gender'] == 'F']['count'].values
            
            # Create bars
            ax.bar(index - bar_width/2, male_data, bar_width, 
                  label='Male', color='lightblue')
            ax.bar(index + bar_width/2, female_data, bar_width,
                  label='Female', color='lightpink')
            
            ax.set_xlabel('Age Group')
            ax.set_ylabel('Performance Count')
            ax.set_xticks(index)
            ax.set_xticklabels(age_groups, rotation=45)
            ax.legend()
            
        PlotUtils.setup_dark_style(ax)
        self.graphs['gender']['canvas'].draw()

    def update_seasonal_pattern(self):
        """Update seasonal pattern graph"""
        ax = self.graphs['seasonal']['ax']
        ax.clear()
        
        seasonal_data = self.data_processor.get_seasonal_pattern()
        if seasonal_data is not None:
            ax1 = ax
            ax2 = ax1.twinx()
            
            x = range(len(seasonal_data.index))
            bars = ax1.bar(x, seasonal_data[('amount', 'count')],
                         color='lightblue', alpha=0.7)
            line = ax2.plot(x, seasonal_data[('amount', 'mean')],
                          color='lightgreen', marker='o', linewidth=2)
            
            ax1.set_xlabel('Season')
            ax1.set_ylabel('Number of Cases', color='lightblue')
            ax2.set_ylabel('Average Amount', color='lightgreen')
            
            ax1.set_xticks(x)
            ax1.set_xticklabels(seasonal_data.index, rotation=45)
            
            for bar in bars:
                height = bar.get_height()
                ax1.text(bar.get_x() + bar.get_width()/2., height,
                        f'{int(height):,}',
                        ha='center', va='bottom', color='white')
                
        PlotUtils.setup_dark_style(ax)
        PlotUtils.setup_dark_style(ax2)
        self.graphs['seasonal']['canvas'].draw()

# utils/data_processor.py
import pandas as pd
import numpy as np
from pathlib import Path
import logging
from datetime import datetime
from scipy.stats import chi2_contingency

def cramers_v(confusion_matrix):
    """
    Calculate Cramer's V correlation coefficient for categorical variables
    
    Args:
        confusion_matrix (numpy.ndarray): Contingency matrix
    
    Returns:
        float: Cramer's V coefficient
    """
    chi2 = chi2_contingency(confusion_matrix)[0]
    n = confusion_matrix.sum()
    min_dim = min(confusion_matrix.shape) - 1
    return np.sqrt(chi2 / (n * min_dim))

class DataProcessor:
    def __init__(self):
        # Initialize logging
        self._setup_logging()
        
        # Initialize data storage
        self.data = None
        self.original_data = None  # Keep original data for reset
        
        # Define required columns
        self.required_columns = ['group', 'country', 'continent', 'rating_year', 'start_year']
        
        # Initialize filter tracking
        self.current_filters = {
            'groups': [],
            'countries': [],
            'continents': [],
            'rating_years': [],
            'start_years': []
        }

    def _setup_logging(self):
        """Setup logging configuration"""
        self.logger = logging.getLogger(__name__)
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)

    def has_data(self):
        """Check if data is loaded"""
        return self.data is not None and not self.data.empty

    def get_data(self):
        """Return current data"""
        return self.data

    def load_file(self, file_path: str):
        """
        Load data from file
        
        Args:
            file_path (str): Path to the data file
            
        Returns:
            tuple: (success: bool, error_message: Optional[str])
        """
        try:
            self.logger.info(f"Loading file: {file_path}")
            path = Path(file_path)
            
            if not path.exists():
                raise FileNotFoundError(f"File not found: {file_path}")
            
            # Load data based on file extension
            if path.suffix.lower() == '.csv':
                self.data = pd.read_csv(file_path)
            elif path.suffix.lower() in ['.xlsx', '.xls']:
                self.data = pd.read_excel(file_path)
            else:
                raise ValueError(f"Unsupported file format: {path.suffix}")

            # Store original data
            self.original_data = self.data.copy()
            
            # Validate and preprocess
            self.validate_and_preprocess_data()
            
            self.logger.info("File loaded successfully")
            return True, None
            
        except Exception as e:
            error_msg = f"Error loading file: {str(e)}"
            self.logger.error(error_msg)
            return False, error_msg

    def validate_and_preprocess_data(self):
        """Validate and preprocess loaded data"""
        # Check required columns
        missing_columns = [col for col in self.required_columns if col not in self.data.columns]
        if missing_columns:
            raise ValueError(f"Missing required columns: {', '.join(missing_columns)}")

        try:
            # Convert data types
            self.data['rating_year'] = pd.to_numeric(self.data['rating_year'], errors='coerce')
            self.data['start_year'] = pd.to_numeric(self.data['start_year'], errors='coerce')
            
            # Ensure string columns are strings and standardize case
            string_columns = ['group', 'country', 'continent']
            for col in string_columns:
                self.data[col] = self.data[col].astype(str).str.strip()
                
            # Remove any rows with NaN values in critical columns
            self.data = self.data.dropna(subset=self.required_columns)
            
            # Create additional derived columns if needed
            if 'age' in self.data.columns and 'age_group' not in self.data.columns:
                age_bins = [0, 18, 30, 45, 60, 100]
                age_labels = ['0-18', '19-30', '31-45', '46-60', '60+']
                self.data['age_group'] = pd.cut(
                    self.data['age'], 
                    bins=age_bins, 
                    labels=age_labels, 
                    right=False
                )
            
            # Try to create season column if date exists
            if 'date' in self.data.columns:
                date_col = pd.to_datetime(self.data['date'])
                self.data['season'] = date_col.dt.month.map({
                    12: 'Winter', 1: 'Winter', 2: 'Winter',
                    3: 'Spring', 4: 'Spring', 5: 'Spring',
                    6: 'Summer', 7: 'Summer', 8: 'Summer',
                    9: 'Autumn', 10: 'Autumn', 11: 'Autumn'
                })
            
            # Store the cleaned data as original
            self.original_data = self.data.copy()
            
            self.logger.info("Data validation and preprocessing completed")
            
        except Exception as e:
            self.logger.error(f"Error in data preprocessing: {str(e)}")
            raise

    def apply_filters(self, groups=None, countries=None, continents=None, 
                     rating_years=None, start_years=None):
        """
        Apply filters to the data
        
        Args:
            groups (list): List of selected groups
            countries (list): List of selected countries
            continents (list): List of selected continents
            rating_years (list): List of selected rating years
            start_years (list): List of selected start years
            
        Returns:
            tuple: (success: bool, error_message: Optional[str])
        """
        try:
            if not self.has_data():
                raise ValueError("No data loaded")

            self.logger.info("Applying filters...")
                
            # Store current filters
            self.current_filters = {
                'groups': groups or [],
                'countries': countries or [],
                'continents': continents or [],
                'rating_years': [int(year) for year in (rating_years or [])],
                'start_years': [int(year) for year in (start_years or [])]
            }

            # Start with original data
            filtered_data = self.original_data.copy()

            # Apply each filter if selections were made
            if groups:
                filtered_data = filtered_data[filtered_data['group'].isin(groups)]
                self.logger.info(f"Filtered by groups: {len(filtered_data)} rows remaining")
            
            if countries:
                filtered_data = filtered_data[filtered_data['country'].isin(countries)]
                self.logger.info(f"Filtered by countries: {len(filtered_data)} rows remaining")
            
            if continents:
                filtered_data = filtered_data[filtered_data['continent'].isin(continents)]
                self.logger.info(f"Filtered by continents: {len(filtered_data)} rows remaining")
            
            if rating_years:
                filtered_data = filtered_data[filtered_data['rating_year'].isin(rating_years)]
                self.logger.info(f"Filtered by rating years: {len(filtered_data)} rows remaining")
            
            if start_years:
                filtered_data = filtered_data[filtered_data['start_year'].isin(start_years)]
                self.logger.info(f"Filtered by start years: {len(filtered_data)} rows remaining")

            # Update current data
            self.data = filtered_data
            
            self.logger.info("Filters applied successfully")
            return True, None
            
        except Exception as e:
            error_msg = f"Error applying filters: {str(e)}"
            self.logger.error(error_msg)
            return False, error_msg

    def reset_filters(self):
        """
        Reset all filters and restore original data
        
        Returns:
            tuple: (success: bool, error_message: Optional[str])
        """
        try:
            self.logger.info("Resetting filters...")
            
            # Restore original data
            self.data = self.original_data.copy()
            
            # Reset filter tracking
            self.current_filters = {
                'groups': [],
                'countries': [],
                'continents': [],
                'rating_years': [],
                'start_years': []
            }
            
            self.logger.info("Filters reset successfully")
            return True, None
            
        except Exception as e:
            error_msg = f"Error resetting filters: {str(e)}"
            self.logger.error(error_msg)
            return False, error_msg

    def get_filter_summary(self):
        """
        Get summary of currently applied filters
        
        Returns:
            str: Summary of applied filters
        """
        summary = []
        
        for filter_name, values in self.current_filters.items():
            if values:
                summary.append(f"{filter_name.capitalize()}: {', '.join(map(str, values))}")
        
        if not summary:
            return "No filters applied"
        
        return "\n".join(summary)

    def get_unique_values(self, column):
        """
        Get unique values for a given column
        
        Args:
            column (str): Column name
            
        Returns:
            list: Sorted list of unique values
        """
        if self.has_data() and column in self.data.columns:
            return sorted(self.data[column].unique())
        return []

    def get_filtered_data_summary(self):
        """
        Get summary statistics of filtered data
        
        Returns:
            str: Summary statistics text
        """
        if not self.has_data():
            return "No data available"

        summary = []
        summary.append(f"Total Records: {len(self.data):,}")
        
        # Group counts
        if 'group' in self.data.columns:
            group_counts = self.data['group'].value_counts()
            summary.append("\nGroup Distribution:")
            for group, count in group_counts.items():
                summary.append(f"{group}: {count:,}")
        
        # Country counts
        if 'country' in self.data.columns:
            country_counts = self.data['country'].value_counts().head(10)
            summary.append("\nTop 10 Countries:")
            for country, count in country_counts.items():
                summary.append(f"{country}: {count:,}")
        
        # Year distribution
        if 'rating_year' in self.data.columns:
            year_counts = self.data['rating_year'].value_counts().sort_index()
            summary.append("\nRating Year Distribution:")
            for year, count in year_counts.items():
                summary.append(f"{year}: {count:,}")

        return "\n".join(summary)

    def export_filtered_data(self, file_path):
        """
        Export filtered data to file
        
        Args:
            file_path (str): Path where to save the file
            
        Returns:
            tuple: (success: bool, error_message: Optional[str])
        """
        try:
            if not self.has_data():
                raise ValueError("No data available to export")

            self.logger.info(f"Exporting data to: {file_path}")
            
            path = Path(file_path)
            if path.suffix.lower() == '.csv':
                self.data.to_csv(file_path, index=False)
            elif path.suffix.lower() in ['.xlsx', '.xls']:
                self.data.to_excel(file_path, index=False)
            else:
                raise ValueError(f"Unsupported export format: {path.suffix}")
            
            self.logger.info("Data exported successfully")
            return True, None
            
        except Exception as e:
            error_msg = f"Error exporting data: {str(e)}"
            self.logger.error(error_msg)
            return False, error_msg

    def get_data_statistics(self):
        """
        Get comprehensive statistics about the data
        
        Returns:
            dict: Dictionary containing various statistics
        """
        if not self.has_data():
            return {"error": "No data available"}

        try:
            stats = {
                "total_records": len(self.data),
                "total_records_original": len(self.original_data),
                "filtered_percentage": (len(self.data) / len(self.original_data) * 100) if self.original_data is not None else 100,
                "groups": self.data['group'].value_counts().to_dict(),
                "countries": self.data['country'].value_counts().to_dict(),
                "continents": self.data['continent'].value_counts().to_dict(),
                "rating_years": self.data['rating_year'].value_counts().sort_index().to_dict(),
                "start_years": self.data['start_year'].value_counts().sort_index().to_dict(),
                "current_filters": self.current_filters
            }
            
            return stats
            
        except Exception as e:
            self.logger.error(f"Error calculating statistics: {str(e)}")
            return {"error": str(e)}

    def get_correlation_matrix(self):
        """
        Calculate correlation matrix for categorical variables using Cramer's V
        
        Returns:
            pandas.DataFrame: Correlation matrix
        """
        if not self.has_data():
            return None
        
        # Select categorical columns
        cat_columns = ['age', 'gender', 'diagnosis', 'country', 'continent']
        
        # Ensure all selected columns exist in the dataframe
        available_columns = [col for col in cat_columns if col in self.data.columns]
        
        if len(available_columns) < 2:
            return None
        
        # Preprocessing: convert age to age groups
        if 'age' in available_columns:
            age_bins = [0, 18, 30, 45, 60, 100]
            age_labels = ['0-18', '19-30', '31-45', '46-60', '60+']
            self.data['age_group'] = pd.cut(
                self.data['age'], 
                bins=age_bins, 
                labels=age_labels, 
                right=False
            )
            available_columns = [col if col != 'age' else 'age_group' for col in available_columns]
        
        # Create correlation matrix
        correlation_matrix = pd.DataFrame(
            index=available_columns, 
            columns=available_columns, 
            dtype=float
        )
        
        # Calculate Cramer's V for each pair of categorical variables
        for i, col1 in enumerate(available_columns):
            for j, col2 in enumerate(available_columns):
                if i == j:
                    correlation_matrix.loc[col1, col2] = 1.0
                elif i < j:
                    # Create contingency table
                    contingency_table = pd.crosstab(self.data[col1], self.data[col2])
                    
                    # Calculate Cramer's V
                    cramer_v = cramers_v(contingency_table.values)
                    
                    # Store in symmetric matrix
                    correlation_matrix.loc[col1, col2] = cramer_v
                    correlation_matrix.loc[col2, col1] = cramer_v
        
        return correlation_matrix

    def get_age_distribution(self):
        """
        Calculate age distribution
        
        Returns:
            pandas.Series: Age group distribution
        """
        if not self.has_data():
            return None
        
        # Ensure age groups exist
        if 'age_group' not in self.data.columns:
            age_bins = [0, 18, 30, 45, 60, 100]
            age_labels = ['0-18', '19-30', '31-45', '46-60', '60+']
            self.data['age_group'] = pd.cut(
                self.data['age'], 
                bins=age_bins, 
                labels=age_labels, 
                right=False
            )
        
        return self.data['age_group'].value_counts().sort_index()

    def get_amount_distribution(self):
        """
        Get distribution of amounts
        
        Returns:
            numpy.array or None: Array of amounts
        """
        if not self.has_data():
            return None
        
        # Assuming there's an 'amount' column
        return self.data.get('amount', pd.Series()).values

    def get_diagnosis_distribution(self):
        """
        Calculate diagnosis distribution
        
        Returns:
            pandas.Series: Diagnosis distribution
        """
        if not self.has_data():
            return None
        
        # Assuming there's a 'diagnosis' column
        return self.data['diagnosis'].value_counts().head(10)

    def get_monthly_trend(self):
        """
        Calculate monthly trend
        
        Returns:
            pandas.Series: Monthly trend
        """
        if not self.has_data():
            return None
        
        # Assuming there's a date column
        if 'date' in self.data.columns:
            try:
                # 날짜 문자열을 datetime으로 변환
                dates = pd.to_datetime(self.data['date'], errors='coerce')
                return dates.dt.to_period('M').value_counts().sort_index()
            except Exception as e:
                print(f"Error processing date column: {e}")
                return None
        elif 'month' in self.data.columns:
            return self.data['month'].value_counts().sort_index()
        else:
            return None

    def get_yearly_trend(self):
        """
        Calculate yearly trend with amount statistics
        
        Returns:
            pandas.DataFrame: Yearly trend with count and mean amount
        """
        if not self.has_data():
            return None
        
        # Assuming 'rating_year' or 'year' column exists
        year_col = 'rating_year' if 'rating_year' in self.data.columns else 'year'
        amount_col = 'amount' if 'amount' in self.data.columns else None
        
        if amount_col:
            return self.data.groupby(year_col).agg({
                amount_col: ['count', 'mean']
            })
        else:
            return self.data[year_col].value_counts().sort_index()

    def get_average_amount_by_age(self):
        """
        Calculate average amount by age group
        
        Returns:
            pandas.Series: Average amount by age group
        """
        if not self.has_data():
            return None
        
        # Create age groups if needed
        if 'age_group' not in self.data.columns:
            age_bins = [0, 18, 30, 45, 60, 100]
            age_labels = ['0-18', '19-30', '31-45', '46-60', '60+']
            self.data['age_group'] = pd.cut(
                self.data.get('age', pd.Series()), 
                bins=age_bins, 
                labels=age_labels, 
                right=False
            )
        
        # Check for amount column
        amount_col = 'amount' if 'amount' in self.data.columns else None
        
        if amount_col:
            return self.data.groupby('age_group')[amount_col].mean(numeric_only=True)
        else:
            return None

    def get_gender_distribution(self):
        """
        Calculate gender distribution by age group
        
        Returns:
            pandas.DataFrame: Gender distribution
        """
        if not self.has_data():
            return None
        
        # Create age groups if needed
        if 'age_group' not in self.data.columns:
            age_bins = [0, 18, 30, 45, 60, 100]
            age_labels = ['0-18', '19-30', '31-45', '46-60', '60+']
            self.data['age_group'] = pd.cut(
                self.data.get('age', pd.Series()), 
                bins=age_bins, 
                labels=age_labels, 
                right=False
            )
        
        # Check for gender column
        if 'gender' not in self.data.columns:
            return None
        
        return self.data.groupby(['age_group', 'gender']).size().reset_index(name='count')


    def get_seasonal_pattern(self):
        """
        Calculate seasonal pattern
        
        Returns:
            pandas.DataFrame: Seasonal pattern with count and mean amount
        """
        if not self.has_data():
            return None
        
        # Add season column if not exists
        if 'season' not in self.data.columns:
            if 'date' in self.data.columns:
                try:
                    date_col = pd.to_datetime(self.data['date'])
                    self.data['season'] = date_col.dt.month.map({
                        12: 'Winter', 1: 'Winter', 2: 'Winter',
                        3: 'Spring', 4: 'Spring', 5: 'Spring',
                        6: 'Summer', 7: 'Summer', 8: 'Summer',
                        9: 'Autumn', 10: 'Autumn', 11: 'Autumn'
                    })
                except Exception as e:
                    print(f"Error processing date column: {e}")
                    return None
            else:
                return None
        
        # Check for amount column
        amount_col = 'amount' if 'amount' in self.data.columns else None
        
        if amount_col:
            return self.data.groupby('season').agg({
                amount_col: ['count', 'mean']
            })
        else:
            return self.data['season'].value_counts().sort_index()

# utils/plot_utils.py
import matplotlib.pyplot as plt
import seaborn as sns

class PlotUtils:
    @staticmethod
    def setup_dark_style(ax):
        """Setup dark style for matplotlib plots"""
        ax.set_facecolor('#2B2B2B')
        ax.tick_params(colors='white', labelsize=10)
        for spine in ax.spines.values():
            spine.set_color('white')
        ax.set_xlabel(ax.get_xlabel(), color='white')
        ax.set_ylabel(ax.get_ylabel(), color='white')
        if ax.get_title():
            ax.set_title(ax.get_title(), color='white', pad=20)

    @staticmethod
    def setup_figure(fig):
        """Setup figure for dark theme"""
        fig.patch.set_facecolor('#2B2B2B')
        fig.subplots_adjust(left=0.15, right=0.95, bottom=0.15, top=0.9)
